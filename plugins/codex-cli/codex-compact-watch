#!/usr/bin/env bash
# codex-compact-watch — Background daemon that auto-intercepts Codex CLI compaction.
#
# Monitors the active Codex session JSONL file for compaction events.
# When Codex writes a "compacted" entry (LLM summarization), this daemon:
#   1. Backs up the post-compaction file
#   2. Runs supercompact on the pre-compaction backup
#   3. Replaces the session file with the supercompact result
#
# Usage:
#   codex-compact-watch                    # Watch the latest session
#   codex-compact-watch --session FILE     # Watch a specific session
#   codex-compact-watch --stop             # Stop the watcher daemon
#   codex-compact-watch --status           # Check if watcher is running
#
# The watcher uses inotifywait (from inotify-tools) if available, falling
# back to polling every 2 seconds.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SUPERCOMPACT_DIR="$(cd "${SCRIPT_DIR}/../../" && pwd)"
PID_FILE="/tmp/codex-compact-watch.pid"
LOG_FILE="${HOME}/.cache/supercompact/codex-watch.log"
METHOD="${SUPERCOMPACT_METHOD:-eitf}"
BUDGET="${SUPERCOMPACT_BUDGET:-80000}"
SESSION_FILE=""

mkdir -p "$(dirname "${LOG_FILE}")"

log() {
    echo "$(date -Iseconds) $*" >> "${LOG_FILE}"
}

# Portable: find most recent file (works on GNU and BSD/macOS)
find_latest_session() {
    local dir="$1"
    # Use ls -t on found files for portability (avoids GNU -printf)
    find "${dir}" -name "rollout-*.jsonl" -type f 2>/dev/null \
        | xargs ls -t 2>/dev/null \
        | head -1
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --session)
            SESSION_FILE="$2"
            shift 2
            ;;
        --stop)
            if [[ -f "${PID_FILE}" ]]; then
                PID=$(cat "${PID_FILE}")
                if kill -0 "${PID}" 2>/dev/null; then
                    kill "${PID}"
                    rm -f "${PID_FILE}"
                    echo "Stopped codex-compact-watch (PID ${PID})"
                else
                    rm -f "${PID_FILE}"
                    echo "Watcher was not running (stale PID file removed)"
                fi
            else
                echo "Watcher is not running"
            fi
            exit 0
            ;;
        --status)
            if [[ -f "${PID_FILE}" ]]; then
                PID=$(cat "${PID_FILE}")
                if kill -0 "${PID}" 2>/dev/null; then
                    echo "codex-compact-watch is running (PID ${PID})"
                    echo "Log: ${LOG_FILE}"
                    tail -5 "${LOG_FILE}" 2>/dev/null || true
                else
                    rm -f "${PID_FILE}"
                    echo "Watcher is not running (stale PID file removed)"
                fi
            else
                echo "Watcher is not running"
            fi
            exit 0
            ;;
        --help|-h)
            echo "Usage: codex-compact-watch [OPTIONS]"
            echo ""
            echo "Background daemon that auto-intercepts Codex CLI compaction."
            echo ""
            echo "Options:"
            echo "  --session FILE   Watch a specific session JSONL file"
            echo "  --stop           Stop the watcher daemon"
            echo "  --status         Check if watcher is running"
            echo "  --help, -h       Show this help"
            exit 0
            ;;
        *)
            echo "Unknown argument: $1" >&2
            exit 1
            ;;
    esac
done

# Check if already running
if [[ -f "${PID_FILE}" ]]; then
    OLD_PID=$(cat "${PID_FILE}")
    if kill -0 "${OLD_PID}" 2>/dev/null; then
        echo "codex-compact-watch is already running (PID ${OLD_PID})"
        echo "Use --stop to stop it first."
        exit 1
    fi
    rm -f "${PID_FILE}"
fi

# Find session to watch (respects CODEX_HOME)
CODEX_SESSIONS="${CODEX_HOME:-${HOME}/.codex}/sessions"

if [[ -z "${SESSION_FILE}" ]]; then
    if [[ ! -d "${CODEX_SESSIONS}" ]]; then
        echo "Error: No Codex sessions found (${CODEX_SESSIONS} does not exist)" >&2
        exit 1
    fi
    SESSION_FILE=$(find_latest_session "${CODEX_SESSIONS}")

    if [[ -z "${SESSION_FILE}" ]]; then
        echo "Error: No Codex session files found" >&2
        exit 1
    fi
fi

if [[ ! -f "${SESSION_FILE}" ]]; then
    echo "Error: Session file not found: ${SESSION_FILE}" >&2
    exit 1
fi

# Record initial state
INITIAL_LINES=$(wc -l < "${SESSION_FILE}")

echo "Watching: ${SESSION_FILE}"
echo "Method: ${METHOD}, Budget: ${BUDGET}"
echo "Log: ${LOG_FILE}"
echo ""
echo "The watcher will run in the background."
echo "Use 'codex-compact-watch --stop' to stop it."
echo "Use 'codex-compact-watch --status' to check status."

# Run the watcher in the background
(
    echo $BASHPID > "${PID_FILE}"
    log "Started watching: ${SESSION_FILE}"
    log "Method: ${METHOD}, Budget: ${BUDGET}"

    PREV_LINES=${INITIAL_LINES}

    # Save a pre-compaction snapshot whenever lines grow significantly
    save_pre_compact_snapshot() {
        cp "${SESSION_FILE}" "${SESSION_FILE}.pre-compact-snapshot"
        log "Pre-compact snapshot saved (${PREV_LINES} lines)"
    }

    check_for_compaction() {
        local current_lines
        current_lines=$(wc -l < "${SESSION_FILE}" 2>/dev/null) || return

        # If lines grew, save a pre-compaction snapshot
        if [[ "${current_lines}" -gt "${PREV_LINES}" ]]; then
            save_pre_compact_snapshot
        fi

        # If the file shrunk significantly, compaction likely happened
        if [[ "${current_lines}" -lt $(( PREV_LINES / 2 )) && "${current_lines}" -gt 2 ]]; then
            log "Detected compaction: ${PREV_LINES} -> ${current_lines} lines"

            # Check if the last line is a compacted entry
            local last_type
            last_type=$(tail -1 "${SESSION_FILE}" | python3 -c "
import json, sys
try:
    r = json.loads(sys.stdin.read())
    print(r.get('type', ''))
except:
    print('')
" 2>/dev/null)

            if [[ "${last_type}" == "compacted" || "${current_lines}" -lt $(( PREV_LINES / 3 )) ]]; then
                log "Compaction confirmed. Running supercompact replacement..."

                # Back up the LLM-compacted version
                cp "${SESSION_FILE}" "${SESSION_FILE}.llm-compact-backup"
                log "LLM compaction backup: ${SESSION_FILE}.llm-compact-backup"

                # Determine source: use pre-compact snapshot if available
                local source_file="${SESSION_FILE}.pre-compact-snapshot"
                if [[ ! -f "${source_file}" ]]; then
                    source_file="${SESSION_FILE}"
                    log "No pre-compact snapshot, compacting current file"
                else
                    log "Using pre-compaction snapshot as source"
                fi

                # Run supercompact on the source, output to temp file
                local output_file="/tmp/supercompact-codex-watch-${BASHPID}.jsonl"
                if (cd "${SUPERCOMPACT_DIR}" && uv run python "${SCRIPT_DIR}/compact_codex.py" \
                    "${source_file}" \
                    --method "${METHOD}" \
                    --budget "${BUDGET}" \
                    --output "${output_file}") 2>> "${LOG_FILE}"; then

                    # Replace the ACTIVE session file (not the backup)
                    mv "${output_file}" "${SESSION_FILE}"
                    log "Supercompact replacement successful — active session updated"
                else
                    log "ERROR: Supercompact failed, keeping LLM compaction"
                    cp "${SESSION_FILE}.llm-compact-backup" "${SESSION_FILE}"
                    rm -f "${output_file}" 2>/dev/null || true
                fi
            fi
        fi

        PREV_LINES=${current_lines}
    }

    # Use inotifywait if available, otherwise poll
    if command -v inotifywait &>/dev/null; then
        log "Using inotifywait for efficient file monitoring"
        while true; do
            inotifywait -qq -e modify "${SESSION_FILE}" 2>/dev/null || true
            sleep 0.5
            check_for_compaction
        done
    else
        log "inotifywait not available, falling back to polling (2s interval)"
        while true; do
            sleep 2
            check_for_compaction
        done
    fi
) &

DAEMON_PID=$!
echo ""
echo "Watcher started (PID ${DAEMON_PID})"
